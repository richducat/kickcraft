<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KickCraft 3D First Person</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 12px;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 14px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="ui">Click to lock pointer. Use W/A/S/D to move, hold mouse to charge, release to shoot. Press Q/E to add spin.</div>
  <!-- Import Three.js and PointerLockControls as ES modules -->
  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
  import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/PointerLockControls.js';

  let scene, camera, renderer, controls;
  let player;
  let keeper, defenders = [];

  // Initialize the scene, camera, renderer, and game objects
  function init() {
    scene = new THREE.Scene();
    // Add a subtle fog for depth
    scene.fog = new THREE.Fog(0x0a3d24, 50, 300);

    // Set up lights: ambient and a directional for shadows
    const ambient = new THREE.AmbientLight(0x444444);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(50, 100, 50);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024, 1024);
    dir.shadow.camera.left = -80;
    dir.shadow.camera.right = 80;
    dir.shadow.camera.top = 80;
    dir.shadow.camera.bottom = -80;
    scene.add(dir);

    // Set up renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Handle resize
    window.addEventListener('resize', onResize);

    // Camera and pointer lock controls
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => {
      if (!controls.isLocked) controls.lock();
    });

    // Create the pitch (grass) using a texture for realism
    const pitchWidth = 100;
    const pitchLength = 160;
    const planeGeom = new THREE.PlaneGeometry(pitchWidth, pitchLength);
    // Load a grass texture; note this is an external asset which may be replaced with your own texture
    const loader = new THREE.TextureLoader();
    const grassTex = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/grasslight-big.jpg');
    grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
    grassTex.repeat.set(6, 10);
    grassTex.encoding = THREE.sRGBEncoding;
    const planeMat = new THREE.MeshStandardMaterial({ map: grassTex, roughness: 1.0, metalness: 0.0 });
    const plane = new THREE.Mesh(planeGeom, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Draw center and goal lines using thin boxes
    const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    function addLine(x1, z1, x2, z2) {
      const dx = x2 - x1;
      const dz = z2 - z1;
      const length = Math.sqrt(dx * dx + dz * dz);
      const lineGeom = new THREE.BoxGeometry(0.1, 0.1, length);
      const line = new THREE.Mesh(lineGeom, lineMat);
      line.position.set((x1 + x2) / 2, 0.05, (z1 + z2) / 2);
      const angle = Math.atan2(dx, dz);
      line.rotation.y = angle;
      scene.add(line);
    }
    // Center line
    addLine(-pitchWidth / 2, 0, pitchWidth / 2, 0);
    // Goal lines (shorter than pitch width)
    const goalWidth = 20;
    addLine(-goalWidth / 2, -pitchLength / 2, goalWidth / 2, -pitchLength / 2);
    addLine(-goalWidth / 2, pitchLength / 2, goalWidth / 2, pitchLength / 2);

    // Create the soccer ball with a shiny PBR material
    const ballGeom = new THREE.SphereGeometry(0.6, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.6 });
    const ball = new THREE.Mesh(ballGeom, ballMat);
    ball.castShadow = true;
    ball.position.set(0, 0.6, 0);
    scene.add(ball);

    // Initialize player state: ball, velocity, spin, charging flag
    player = {
      ball: ball,
      vel: new THREE.Vector3(),
      spin: new THREE.Vector3(),
      charging: false,
      chargeStart: 0,
      keyState: {}
    };

    // Key events to track movement and spin
    document.addEventListener('keydown', (e) => {
      player.keyState[e.code] = true;
      if (e.code === 'KeyQ') player.spin.set(0, 1, 0); // spin left
      if (e.code === 'KeyE') player.spin.set(0, -1, 0); // spin right
    });
    document.addEventListener('keyup', (e) => {
      player.keyState[e.code] = false;
      if (e.code === 'KeyQ' || e.code === 'KeyE') player.spin.set(0, 0, 0);
    });

    // Mouse controls: charge and shoot
    document.addEventListener('mousedown', (e) => {
      player.charging = true;
      player.chargeStart = performance.now();
    });
    document.addEventListener('mouseup', (e) => {
      if (player.charging) {
        const now = performance.now();
        const chargeDuration = now - player.chargeStart;
        const power = Math.min(chargeDuration / 1000, 1.0);
        const shootDir = new THREE.Vector3();
        camera.getWorldDirection(shootDir);
        shootDir.y = 0;
        shootDir.normalize();
        player.vel.copy(shootDir).multiplyScalar(power * 25);
        player.charging = false;
      }
    });

    // Create the goalkeeper using a capsule geometry for smoother shape
    const keeperGeom = new THREE.CapsuleGeometry(0.8, 2.5, 8, 16);
    const keeperMat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.3, metalness: 0.1 });
    keeper = new THREE.Mesh(keeperGeom, keeperMat);
    keeper.castShadow = true;
    keeper.position.set(0, 2.5, -pitchLength / 2 + 1);
    scene.add(keeper);

    // Create simple defenders as capsules; they oscillate horizontally
    const defenderCount = 6;
    const defColor = new THREE.Color(0x0044ff);
    for (let i = 0; i < defenderCount; i++) {
      const defGeom = new THREE.CapsuleGeometry(0.6, 2.0, 8, 16);
      const defMat = new THREE.MeshStandardMaterial({ color: defColor });
      const defender = new THREE.Mesh(defGeom, defMat);
      defender.castShadow = true;
      const x = (i - defenderCount / 2 + 0.5) * 8;
      const z = -40 - i * 5;
      defender.position.set(x, 2.0, z);
      defenders.push(defender);
      scene.add(defender);
    }

    // Create crowd as small boxes along both sidelines
    const crowdCount = 50;
    for (let i = 0; i < crowdCount; i++) {
      const crowdGeom = new THREE.BoxGeometry(1.0, 4.0, 1.0);
      const color = new THREE.Color().setHSL(Math.random(), 0.6, 0.5);
      const crowdMat = new THREE.MeshBasicMaterial({ color: color });
      const fan1 = new THREE.Mesh(crowdGeom, crowdMat);
      fan1.position.set(-pitchWidth / 2 - 2, 2.0, -pitchLength / 2 + i * (pitchLength / crowdCount));
      scene.add(fan1);
      const fan2 = fan1.clone();
      fan2.position.set(pitchWidth / 2 + 2, 2.0, -pitchLength / 2 + i * (pitchLength / crowdCount));
      scene.add(fan2);
    }

    // Position the camera initially behind the ball
    camera.position.set(0, 2.5, 10);
    camera.lookAt(player.ball.position.x, 1.5, player.ball.position.z);

    // Start the game loop
    animate();
  }

  // Adjust camera and renderer size on window resize
  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Update AI for goalkeeper and defenders
  function updateAI(dt) {
    // Goalkeeper tries to align with predicted ball x-position at the goal plane
    const targetZ = -80; // approximate goal plane Z
    const timeToGoal = (targetZ - player.ball.position.z) / (player.vel.z || 1e-6);
    let predictedX = player.ball.position.x + player.vel.x * Math.max(timeToGoal, 0);
    predictedX = THREE.MathUtils.clamp(predictedX, -10, 10);
    const speed = 12;
    const dx = predictedX - keeper.position.x;
    keeper.position.x += Math.sign(dx) * Math.min(Math.abs(dx), speed * dt);
    // Rotate keeper slightly as if diving
    const rotationTarget = -dx / 10;
    keeper.rotation.z = THREE.MathUtils.lerp(keeper.rotation.z, rotationTarget, dt * 5);
    // Defenders move side-to-side to block
    defenders.forEach((d, idx) => {
      const oscillation = Math.sin((performance.now() * 0.001) + idx) * 4;
      d.position.x = (idx - defenders.length / 2 + 0.5) * 8 + oscillation;
    });
  }

  // Main animation loop
  let lastTime = performance.now();
  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    // Handle player movement using WASD
    const moveDir = new THREE.Vector3();
    if (player.keyState['KeyW']) moveDir.z -= 1;
    if (player.keyState['KeyS']) moveDir.z += 1;
    if (player.keyState['KeyA']) moveDir.x -= 1;
    if (player.keyState['KeyD']) moveDir.x += 1;
    moveDir.normalize();
    if (moveDir.length() > 0) {
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.y = 0;
      dir.normalize();
      const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0, 1, 0));
      const worldMove = new THREE.Vector3();
      worldMove.addScaledVector(dir, moveDir.z);
      worldMove.addScaledVector(right, moveDir.x);
      worldMove.normalize().multiplyScalar(10 * dt);
      player.ball.position.add(worldMove);
      camera.position.add(worldMove);
    }
    // Update ball with velocity and spin
    if (player.vel.lengthSq() > 0.0001) {
      player.ball.position.addScaledVector(player.vel, dt);
      player.vel.multiplyScalar(0.98);
      if (player.spin.lengthSq() > 0.0001) {
        const lift = new THREE.Vector3().crossVectors(player.spin, player.vel).multiplyScalar(0.1);
        player.vel.add(lift);
        player.spin.multiplyScalar(0.98);
      }
    }
    // Confine ball within pitch
    const maxX = 45, maxZ = 75;
    if (player.ball.position.x < -maxX) {
      player.ball.position.x = -maxX; player.vel.x *= -0.5;
    }
    if (player.ball.position.x > maxX) {
      player.ball.position.x = maxX; player.vel.x *= -0.5;
    }
    if (player.ball.position.z < -maxZ) {
      player.ball.position.z = -maxZ; player.vel.z *= -0.5;
    }
    if (player.ball.position.z > maxZ) {
      player.ball.position.z = maxZ; player.vel.z *= -0.5;
    }
    // Keep the camera at a constant height and looking at the ball
    camera.position.y = 2.5;
    camera.lookAt(player.ball.position.x, 1.5, player.ball.position.z);
    // Update AI elements
    updateAI(dt);
    renderer.render(scene, camera);
  }

  // Initialize after page load
  init();
  </script>
</body>
</html>
