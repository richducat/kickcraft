<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KickCraft Soccer – Pseudo‑3D 11v11</title>
  <style>
    /* Full page canvas and UI styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #003300;
      font-family: sans-serif;
      overflow: hidden;
    }
    #ui {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 5;
      pointer-events: none;
    }
    #score {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 5;
      pointer-events: none;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none; /* allow pointer events */
    }
  </style>
</head>
<body>
  <div id="ui">W/A/S/D: Move · Q/E: Spin · Shift: Sprint · Tab: Switch Player · Left Click: Shoot (hold for power) · Right Click: Pass</div>
  <div id="score">Level 1 | 0 – 0</div>
  <canvas id="canvas"></canvas>
  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();
    /*
      Game settings and constants
    */
    const PITCH_W = 90;   // world units width
    const PITCH_L = 130;  // world units length
    const GOAL_W = 24;
    const STRIPE_COUNT = 10;
    // Convert world x,z to screen coordinates with simple perspective scaling
    function worldToScreen(x, z) {
      // scale based on z: far (negative z) appears smaller, near (positive z) appears larger
      const perspective = 0.6 + (z + PITCH_L/2) / PITCH_L; // from 0.1 to 1.1 roughly
      const screenX = width / 2 + x * perspective * (width / PITCH_W) * 0.45;
      const screenY = height / 2 - (z + PITCH_L/4) * (height / PITCH_L) * 0.7;
      return { x: screenX, y: screenY, scale: perspective };
    }
    // Player prototype
    class Player {
      constructor(team, role, x, z) {
        this.team = team; // 'pt' or 'fr'
        this.role = role;
        this.x = x;
        this.z = z;
        this.vx = 0;
        this.vz = 0;
        this.speed = 8; // base speed
        this.selected = false;
        this.hasBall = false;
      }
    }
    // Initialise teams with positions (11 per side)
    function initTeams() {
      const pt = [];
      const fr = [];
      // Portugal formation 4-3-3
      pt.push(new Player('pt','GK', 0, PITCH_L/2 - 5));
      pt.push(new Player('pt','RB', PITCH_W/4, PITCH_L/2 - 20));
      pt.push(new Player('pt','RCB', PITCH_W/8, PITCH_L/2 - 25));
      pt.push(new Player('pt','LCB', -PITCH_W/8, PITCH_L/2 - 25));
      pt.push(new Player('pt','LB', -PITCH_W/4, PITCH_L/2 - 20));
      pt.push(new Player('pt','CDM', 0, PITCH_L/2 - 40));
      pt.push(new Player('pt','RCM', PITCH_W/5, PITCH_L/2 - 50));
      pt.push(new Player('pt','LCM', -PITCH_W/5, PITCH_L/2 - 50));
      pt.push(new Player('pt','RW', PITCH_W/3, PITCH_L/2 - 60));
      pt.push(new Player('pt','ST', 0, PITCH_L/2 - 65));
      pt.push(new Player('pt','LW', -PITCH_W/3, PITCH_L/2 - 60));
      // France formation 4-3-3 mirrored
      fr.push(new Player('fr','GK', 0, -PITCH_L/2 + 5));
      fr.push(new Player('fr','RB', -PITCH_W/4, -PITCH_L/2 + 20));
      fr.push(new Player('fr','RCB', -PITCH_W/8, -PITCH_L/2 + 25));
      fr.push(new Player('fr','LCB', PITCH_W/8, -PITCH_L/2 + 25));
      fr.push(new Player('fr','LB', PITCH_W/4, -PITCH_L/2 + 20));
      fr.push(new Player('fr','CDM', 0, -PITCH_L/2 + 40));
      fr.push(new Player('fr','RCM', -PITCH_W/5, -PITCH_L/2 + 50));
      fr.push(new Player('fr','LCM', PITCH_W/5, -PITCH_L/2 + 50));
      fr.push(new Player('fr','RW', -PITCH_W/3, -PITCH_L/2 + 60));
      fr.push(new Player('fr','ST', 0, -PITCH_L/2 + 65));
      fr.push(new Player('fr','LW', PITCH_W/3, -PITCH_L/2 + 60));
      return { pt, fr };
    }
    let { pt: ptPlayers, fr: frPlayers } = initTeams();
    let selectedIndex = 0;
    ptPlayers[selectedIndex].selected = true;
    // Ball state
    const ball = {
      x: 0,
      z: 0,
      vx: 0,
      vz: 0,
      spinZ: 0,
      radius: 1.0,
    };
    // Score and level
    let scoreUs = 0;
    let scoreThem = 0;
    let level = 1;
    let goalsForNext = 2;
    // Input state
    const keys = {};
    let charging = false;
    let chargeStart = 0;
    let spinDir = 0; // -1 for left, 1 for right, 0 none
    // Trap-lock to prevent sticky ball
    let trapLock = 0;
    let trapOwner = null;
    // Event listeners
    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (e.code === 'Tab') {
        // switch selected player
        ptPlayers[selectedIndex].selected = false;
        selectedIndex = (selectedIndex + 1) % ptPlayers.length;
        ptPlayers[selectedIndex].selected = true;
        e.preventDefault();
      }
      if (e.code === 'KeyQ') spinDir = -1;
      if (e.code === 'KeyE') spinDir = 1;
    });
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
      if (e.code === 'KeyQ' || e.code === 'KeyE') spinDir = 0;
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    canvas.addEventListener('mousedown', e => {
      if (e.button === 0) {
        charging = true;
        chargeStart = performance.now();
      }
    });
    canvas.addEventListener('mouseup', e => {
      if (e.button === 0 && charging) {
        // Shoot ball from selected player towards cursor
        const now = performance.now();
        const chargeDur = now - chargeStart;
        const power = Math.min(chargeDur / 1000, 1.0);
        const sel = ptPlayers[selectedIndex];
        // Convert screen mouse to world direction (approximate inverse)
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        // approximate world target z via y mapping
        const targetZ = ((height/2 - my) / (height / PITCH_L) * (PITCH_L / 0.7)) - PITCH_L/4;
        const targetX = (mx - width/2) / ((width / PITCH_W) * 0.45 * (0.6 + (targetZ + PITCH_L/2) / PITCH_L));
        const dx = targetX - sel.x;
        const dz = targetZ - sel.z;
        const len = Math.hypot(dx, dz) || 1;
        const speed = 40 * power;
        ball.vx = (dx/len) * speed;
        ball.vz = (dz/len) * speed;
        // apply spin
        if (spinDir !== 0) {
          ball.spinZ = spinDir * 0.1;
        }
        // detach from any carrier
        trapOwner = null;
        trapLock = 200;
        charging = false;
      }
      if (e.button === 2) {
        // Pass to selected player: choose nearest teammate ahead
        const sel = ptPlayers[selectedIndex];
        let best = null;
        let bestDist = Infinity;
        ptPlayers.forEach((p,i) => {
          if (i !== selectedIndex) {
            const dz = p.z - sel.z;
            const dx = p.x - sel.x;
            const dist = dx*dx + dz*dz;
            if (dz < 0 && dist < bestDist) {
              bestDist = dist;
              best = p;
            }
          }
        });
        if (!best) {
          // if none ahead, pick any except selected
          best = ptPlayers[(selectedIndex+1)%ptPlayers.length];
        }
        const dx = best.x - sel.x;
        const dz = best.z - sel.z;
        const len = Math.hypot(dx, dz) || 1;
        const speed = 25;
        ball.vx = (dx/len) * speed;
        ball.vz = (dz/len) * speed;
        trapOwner = null;
        trapLock = 150;
      }
    });
    /*
      Game loop
    */
    let lastTime = performance.now();
    function update() {
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      // Update trapLock timer
      if (trapLock > 0) trapLock -= dt * 1000;
      // Move selected player with keys
      const sel = ptPlayers[selectedIndex];
      let moveX = 0, moveZ = 0;
      if (keys['KeyW'] || keys['ArrowUp']) moveZ -= 1;
      if (keys['KeyS'] || keys['ArrowDown']) moveZ += 1;
      if (keys['KeyA'] || keys['ArrowLeft']) moveX -= 1;
      if (keys['KeyD'] || keys['ArrowRight']) moveX += 1;
      let speedMod = (keys['ShiftLeft'] || keys['ShiftRight']) ? 1.5 : 1.0;
      const lenMv = Math.hypot(moveX, moveZ);
      if (lenMv > 0) {
        moveX /= lenMv;
        moveZ /= lenMv;
        sel.x += moveX * sel.speed * speedMod * dt;
        sel.z += moveZ * sel.speed * speedMod * dt;
        // clamp inside pitch boundaries for PT
        sel.x = Math.max(-PITCH_W/2 + 2, Math.min(PITCH_W/2 - 2, sel.x));
        sel.z = Math.max(0, Math.min(PITCH_L/2 - 2, sel.z));
      }
      // Move other PT players loosely toward their role anchor positions
      ptPlayers.forEach((p,i) => {
        if (i !== selectedIndex) {
          let targetX, targetZ;
          switch (p.role) {
            case 'RB': targetX = PITCH_W/4; targetZ = PITCH_L/2 - 20; break;
            case 'RCB': targetX = PITCH_W/8; targetZ = PITCH_L/2 - 25; break;
            case 'LCB': targetX = -PITCH_W/8; targetZ = PITCH_L/2 - 25; break;
            case 'LB': targetX = -PITCH_W/4; targetZ = PITCH_L/2 - 20; break;
            case 'CDM': targetX = 0; targetZ = PITCH_L/2 - 40; break;
            case 'RCM': targetX = PITCH_W/5; targetZ = PITCH_L/2 - 50; break;
            case 'LCM': targetX = -PITCH_W/5; targetZ = PITCH_L/2 - 50; break;
            case 'RW': targetX = PITCH_W/3; targetZ = PITCH_L/2 - 60; break;
            case 'ST': targetX = 0; targetZ = PITCH_L/2 - 65; break;
            case 'LW': targetX = -PITCH_W/3; targetZ = PITCH_L/2 - 60; break;
            case 'GK': targetX = 0; targetZ = PITCH_L/2 - 5; break;
            default: targetX = p.x; targetZ = p.z; break;
          }
          const dx = targetX - p.x;
          const dz = targetZ - p.z;
          const dist = Math.hypot(dx, dz);
          if (dist > 0.5) {
            p.x += (dx/dist) * p.speed * 0.5 * dt;
            p.z += (dz/dist) * p.speed * 0.5 * dt;
          }
        }
      });
      // AI for France players: move toward ball if near, otherwise keep formation
      frPlayers.forEach((p,i) => {
        let targetX, targetZ;
        // Goalkeeper tracks ball horizontally when ball in their half
        if (p.role === 'GK') {
          targetX = Math.max(-GOAL_W/2 + 2, Math.min(GOAL_W/2 - 2, ball.x));
          targetZ = -PITCH_L/2 + 5;
        } else {
          // If ball is near (within 30 units), chase
          const dzBall = ball.z - p.z;
          const dxBall = ball.x - p.x;
          const dist = Math.hypot(dxBall, dzBall);
          if (dist < 30) {
            targetX = ball.x;
            targetZ = ball.z;
          } else {
            // formation positions mirrored
            switch (p.role) {
              case 'RB': targetX = -PITCH_W/4; targetZ = -PITCH_L/2 + 20; break;
              case 'RCB': targetX = -PITCH_W/8; targetZ = -PITCH_L/2 + 25; break;
              case 'LCB': targetX = PITCH_W/8; targetZ = -PITCH_L/2 + 25; break;
              case 'LB': targetX = PITCH_W/4; targetZ = -PITCH_L/2 + 20; break;
              case 'CDM': targetX = 0; targetZ = -PITCH_L/2 + 40; break;
              case 'RCM': targetX = -PITCH_W/5; targetZ = -PITCH_L/2 + 50; break;
              case 'LCM': targetX = PITCH_W/5; targetZ = -PITCH_L/2 + 50; break;
              case 'RW': targetX = -PITCH_W/3; targetZ = -PITCH_L/2 + 60; break;
              case 'ST': targetX = 0; targetZ = -PITCH_L/2 + 65; break;
              case 'LW': targetX = PITCH_W/3; targetZ = -PITCH_L/2 + 60; break;
              default: targetX = p.x; targetZ = p.z; break;
            }
          }
        }
        const dx = targetX - p.x;
        const dz = targetZ - p.z;
        const dist = Math.hypot(dx, dz);
        if (dist > 0.5) {
          p.x += (dx/dist) * p.speed * dt;
          p.z += (dz/dist) * p.speed * dt;
        }
        // clamp inside pitch boundaries
        p.x = Math.max(-PITCH_W/2 + 2, Math.min(PITCH_W/2 - 2, p.x));
        p.z = Math.max(-PITCH_L/2 + 2, Math.min(0, p.z));
      });
      // Move ball if free
      if (!trapOwner) {
        ball.x += ball.vx * dt;
        ball.z += ball.vz * dt;
        // Friction
        ball.vx *= 0.99;
        ball.vz *= 0.99;
        // Spin effect (Magnus) – spinZ adds sideways acceleration
        if (Math.abs(ball.spinZ) > 0.001) {
          ball.vx += ball.spinZ * (-ball.vz) * 0.02;
          ball.vz += ball.spinZ * ball.vx * 0.02;
          ball.spinZ *= 0.98;
        }
      } else {
        // attach ball to trap owner
        ball.x = trapOwner.x;
        ball.z = trapOwner.z + (trapOwner.team === 'pt' ? -2 : 2);
        ball.vx = 0;
        ball.vz = 0;
      }
      // Check ball collisions with players
      function checkCollision(players) {
        players.forEach(p => {
          const dx = ball.x - p.x;
          const dz = ball.z - p.z;
          const dist = Math.hypot(dx, dz);
          if (dist < 1.8 && trapLock <= 0) {
            // assign carrier
            trapOwner = p;
            trapLock = 300;
          }
        });
      }
      checkCollision(ptPlayers);
      checkCollision(frPlayers);
      // Ball out-of-bounds and goals
      const goalZFar = -PITCH_L/2 + 3;
      const goalZNear = PITCH_L/2 - 3;
      // Left/right boundaries
      if (ball.x < -PITCH_W/2 + ball.radius) {
        ball.x = -PITCH_W/2 + ball.radius;
        ball.vx *= -0.8;
      }
      if (ball.x > PITCH_W/2 - ball.radius) {
        ball.x = PITCH_W/2 - ball.radius;
        ball.vx *= -0.8;
      }
      // Far goal or behind far
      if (ball.z < goalZFar) {
        // far goal (France) – if between posts then score us
        if (Math.abs(ball.x) < GOAL_W/2) {
          scoreUs++;
          if (scoreUs >= goalsForNext) {
            level++;
            goalsForNext++;
            // Increase AI speed and difficulty
            frPlayers.forEach(p => { p.speed *= 1.1; });
          }
        }
        resetAfterGoal();
      }
      // Near goal or behind near
      if (ball.z > goalZNear) {
        // near goal (Portugal) – if between posts then they score
        if (Math.abs(ball.x) < GOAL_W/2) {
          scoreThem++;
        }
        resetAfterGoal();
      }
    }
    function resetAfterGoal() {
      // reset positions
      const teams = initTeams();
      ptPlayers = teams.pt;
      frPlayers = teams.fr;
      selectedIndex = 0;
      ptPlayers[selectedIndex].selected = true;
      ball.x = 0;
      ball.z = 0;
      ball.vx = ball.vz = 0;
      trapOwner = null;
      trapLock = 200;
      // update scoreboard
      document.getElementById('score').textContent = `Level ${level} | ${scoreUs} – ${scoreThem}`;
    }
    function draw() {
      ctx.clearRect(0,0,width,height);
      // Draw pitch stripes with perspective
      for (let i = 0; i < STRIPE_COUNT; i++) {
        const zStart = -PITCH_L/2 + (i * PITCH_L / STRIPE_COUNT);
        const zEnd = -PITCH_L/2 + ((i+1) * PITCH_L / STRIPE_COUNT);
        const color = i % 2 === 0 ? '#036d2a' : '#025a22';
        // Top edge and bottom edge in screen space for trapezoid slice
        const topLeft = worldToScreen(-PITCH_W/2, zStart);
        const topRight = worldToScreen(PITCH_W/2, zStart);
        const bottomLeft = worldToScreen(-PITCH_W/2, zEnd);
        const bottomRight = worldToScreen(PITCH_W/2, zEnd);
        ctx.beginPath();
        ctx.moveTo(topLeft.x, topLeft.y);
        ctx.lineTo(topRight.x, topRight.y);
        ctx.lineTo(bottomRight.x, bottomRight.y);
        ctx.lineTo(bottomLeft.x, bottomLeft.y);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }
      // Draw goals (lines across posts)
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      // far goal
      const gfarL = worldToScreen(-GOAL_W/2, -PITCH_L/2 + 3);
      const gfarR = worldToScreen(GOAL_W/2, -PITCH_L/2 + 3);
      ctx.beginPath();
      ctx.moveTo(gfarL.x, gfarL.y);
      ctx.lineTo(gfarR.x, gfarR.y);
      ctx.stroke();
      // near goal
      const gnearL = worldToScreen(-GOAL_W/2, PITCH_L/2 - 3);
      const gnearR = worldToScreen(GOAL_W/2, PITCH_L/2 - 3);
      ctx.beginPath();
      ctx.moveTo(gnearL.x, gnearL.y);
      ctx.lineTo(gnearR.x, gnearR.y);
      ctx.stroke();
      // Draw crowd as small boxes
      const fanCount = 40;
      for (let i = 0; i < fanCount; i++) {
        const zFan = -PITCH_L/2 + i * (PITCH_L / fanCount);
        const left = worldToScreen(-PITCH_W/2 - 6, zFan);
        const right = worldToScreen(PITCH_W/2 + 6, zFan);
        const size = 4 * left.scale;
        ctx.fillStyle = i % 2 === 0 ? '#0033cc' : '#cc3300';
        ctx.fillRect(left.x - size/2, left.y - size, size, size * 2);
        ctx.fillRect(right.x - size/2, right.y - size, size, size * 2);
      }
      // Draw France players
      frPlayers.forEach(p => {
        drawPlayer(p, 'blue');
      });
      // Draw Portugal players
      ptPlayers.forEach(p => {
        drawPlayer(p, 'green');
      });
      // Draw selected highlight
      const sel = ptPlayers[selectedIndex];
      const scSel = worldToScreen(sel.x, sel.z);
      ctx.beginPath();
      ctx.arc(scSel.x, scSel.y - 10 * scSel.scale, 15 * scSel.scale, 0, Math.PI * 2);
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Draw ball
      const scBall = worldToScreen(ball.x, ball.z);
      const r = ball.radius * scBall.scale * (width / PITCH_W) * 0.5;
      ctx.beginPath();
      ctx.arc(scBall.x, scBall.y, r, 0, Math.PI * 2);
      ctx.fillStyle = '#f5f5f5';
      ctx.fill();
      ctx.strokeStyle = '#333333';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    // Helper to draw a player with basic body/legs as pseudo‑3D person
    function drawPlayer(p, kit) {
      const sc = worldToScreen(p.x, p.z);
      const bodyH = 20 * sc.scale;
      const bodyW = 10 * sc.scale;
      const headR = 5 * sc.scale;
      // body
      ctx.fillStyle = kit;
      ctx.fillRect(sc.x - bodyW/2, sc.y - bodyH, bodyW, bodyH);
      // shorts
      ctx.fillStyle = kit === 'blue' ? '#ffffff' : '#ff0000';
      ctx.fillRect(sc.x - bodyW/2, sc.y - bodyH/3, bodyW, bodyH / 3);
      // socks
      ctx.fillStyle = kit === 'blue' ? '#ff0000' : '#ffff00';
      ctx.fillRect(sc.x - bodyW/2, sc.y - bodyH/3 + bodyH/3, bodyW, bodyH / 3);
      // head
      ctx.beginPath();
      ctx.arc(sc.x, sc.y - bodyH - headR, headR, 0, Math.PI * 2);
      ctx.fillStyle = '#ffe0bd';
      ctx.fill();
    }
    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    // Start loop
    loop();
  })();
  </script>
</body>
</html>