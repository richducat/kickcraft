<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>KickCraft — Realistic 11v11 (pseudo-3D 2D)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- React 18 + ReactDOM via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel so we can ship this as a single file without a build step -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root { color-scheme: dark; }
      html, body { margin:0; background:#0b0b0b; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
      #root { min-height:100vh; display:flex; }
      /* keep overlay text crisp */
      .hud { background:rgba(0,0,0,.5); padding:6px 8px; border-radius:8px; font-size:12px; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <div id="diag" style="position:fixed; inset:0; display:none; z-index:9999; background:#0b1220; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:20px;">
      <div style="max-width:720px; margin:0 auto;">
        <div style="font-weight:900; font-size:28px; letter-spacing:-0.02em;">KickCraft couldn’t start</div>
        <div id="diag-msg" style="margin-top:10px; opacity:0.85; line-height:1.4;"></div>
        <div style="margin-top:14px; opacity:0.75; font-size:12px;">
          Tip: open this link in Safari/Chrome (not inside Telegram), then refresh.
        </div>
      </div>
    </div>

    <script>
      (function(){
        function show(msg){
          var box=document.getElementById('diag');
          var m=document.getElementById('diag-msg');
          if(!box||!m) return;
          m.textContent=msg;
          box.style.display='block';
        }
        window.addEventListener('error', function(e){
          show('Error: ' + (e && e.message ? e.message : 'unknown'));
        });
        window.addEventListener('unhandledrejection', function(e){
          show('Error: ' + (e && e.reason ? (e.reason.message || String(e.reason)) : 'unknown'));
        });
        setTimeout(function(){
          if(typeof window.React==='undefined' || typeof window.ReactDOM==='undefined'){
            show('React did not load (blocked CDN).');
          } else if (!document.querySelector('script[src*="babel"]')) {
            show('Babel did not load (blocked CDN).');
          }
        }, 1500);
      })();
    </script>

    <script type="text/babel">
      // === YOUR COMPONENT EXACTLY AS PROVIDED ===
      const { useEffect, useRef, useState } = React;

      // ---- World (logical units) ----
      const W = 1100;            // world width
      const H = 620;             // world height
      const GOAL_W = 320;        // px (world units)
      const BALL_R = 10;         // px
      const RESTITUTION = 0.58;  // bounce

      const NUM_DEFENDERS = 10;   // France outfield (plus GK)
      const NUM_TEAMMATES = 10;   // Portugal outfield (plus GK)

      const MAX_ENGAGERS = 2;      // baseline; levels override
      const ENGAGE_RADIUS = 180;   // px
      const HOLD_RADIUS = 80;      // px
      const DEFENDER_SPEED = 180;  // px/s
      const TEAMMATE_SPEED = 170;  // px/s
      const CAPTURE_SPEED_MAX = 260; // px/s
      const PASS_MIN = 360, PASS_MAX = 780; // px/s

      // Shot tuning
      const FINESSE_SPIN = 85;        // px/s^2 lateral accel
      const DRIVEN_SPEED_F = 1.18;    // speed factor
      const FINESSE_SPEED_F = 0.82;   // speed factor
      const SHOT_SPRAY = 0.03;        // radians of random error

      // GK tuning (Buffon mode)
      const GK_REACT_MS = 80;        // reaction delay before moving
      const GK_PARRY_SPEED = 520;     // min ball speed to force parry
      const GK_HOLD_SPEED = 420;      // below this, keeper can catch/hold

      // Level configs — difficulty ramps each level
      const LEVELS = [
        { name: "Friendly",       maxEngagers: 2, defenderSpeed: 200, engageRadius: 185, holdRadius: 88, captureSpeedMax: 280, passGrace: 700 },
        { name: "Warmup",         maxEngagers: 2, defenderSpeed: 220, engageRadius: 195, holdRadius: 84, captureSpeedMax: 300, passGrace: 650 },
        { name: "League Match",   maxEngagers: 2, defenderSpeed: 240, engageRadius: 205, holdRadius: 82, captureSpeedMax: 320, passGrace: 620 },
        { name: "Cup Tie",        maxEngagers: 3, defenderSpeed: 255, engageRadius: 215, holdRadius: 80, captureSpeedMax: 340, passGrace: 580 },
        { name: "Quarterfinal",   maxEngagers: 3, defenderSpeed: 270, engageRadius: 225, holdRadius: 78, captureSpeedMax: 360, passGrace: 540 },
        { name: "Semifinal",      maxEngagers: 3, defenderSpeed: 285, engageRadius: 235, holdRadius: 76, captureSpeedMax: 380, passGrace: 520 },
        { name: "Final",          maxEngagers: 3, defenderSpeed: 300, engageRadius: 245, holdRadius: 74, captureSpeedMax: 400, passGrace: 500 },
      ];

      // Pseudo-3D perspective params (top is far, bottom is near)
      const PERS = { top: 24, bottom: H - 24, sFar: 0.55, sNear: 1.0 };

      // Kits & numbers
      const KIT_FR = { jersey: "#0055A4", shorts: "#FFFFFF", socks: "#EF4135" }; // blue/white/red
      const KIT_PT = { jersey: "#046A38", shorts: "#DA291C", socks: "#FFCC00" }; // green/red/yellow
      const SKIN = "#f1d3b6";
      const NUM_BY_ROLE = { GK:1,RB:2,LB:3,RCB:4,LCB:5,CDM:6,RCM:8,LCM:10,RW:7,LW:11,ST:9 };

      // Roles (11) in order for each side
      const ROLES_PT = ["LB","LCB","RCB","RB","CDM","LCM","RCM","LW","ST","RW"]; // GK separate
      const ROLES_FR = ["RB","RCB","LCB","LB","CDM","RCM","LCM","RW","ST","LW"]; // mirror-ish

      function KickCraft() {
        const wrapRef = useRef(null);
        const canvasRef = useRef(null);
        const [diag, setDiag] = useState([]);

        useEffect(() => {
          const wrap = wrapRef.current;
          const cvs = canvasRef.current;
          const dpr = Math.min(2, window.devicePixelRatio || 1);
          const ctx = cvs.getContext('2d');

          function resize(){
            const wrapW = wrap.clientWidth || W;
            const ratio = H / W;
            const wrapH = Math.max(400, Math.floor(wrapW * ratio));
            cvs.width = Math.floor(wrapW * dpr);
            cvs.height = Math.floor(wrapH * dpr);
            cvs.style.width = wrapW + 'px';
            cvs.style.height = wrapH + 'px';
          }
          resize();
          window.addEventListener('resize', resize);

          function scaleAtY(y){ const t = Math.max(0, Math.min(1, y / H)); return PERS.sFar + (PERS.sNear - PERS.sFar) * t; }
          function project(x, y){ const s = scaleAtY(y); const px = (x - W/2) * s + W/2; const py = PERS.top + (PERS.bottom - PERS.top) * (y / H); return { x: px, y: py, s }; }
          function unproject(px, py){ const t = (py - PERS.top) / (PERS.bottom - PERS.top); const y = Math.max(0, Math.min(H, t * H)); const s = scaleAtY(y); const x = ((px - W/2) / (s || 1)) + W/2; return { x, y }; }

          const ANCHORS_PT = { GK:{x:0,y:H-52}, LB:{x:-260,y:H*0.68}, LCB:{x:-120,y:H*0.68}, RCB:{x:120,y:H*0.68}, RB:{x:260,y:H*0.68}, CDM:{x:0,y:H*0.58}, LCM:{x:-120,y:H*0.56}, RCM:{x:120,y:H*0.56}, LW:{x:-220,y:H*0.42}, ST:{x:0,y:H*0.40}, RW:{x:220,y:H*0.42} };
          const ANCHORS_FR = { GK:{x:0,y:52}, RB:{x:260,y:H*0.32}, RCB:{x:120,y:H*0.32}, LCB:{x:-120,y:H*0.32}, LB:{x:-260,y:H*0.32}, CDM:{x:0,y:H*0.42}, RCM:{x:120,y:H*0.44}, LCM:{x:-120,y:H*0.44}, RW:{x:220,y:H*0.22}, ST:{x:0,y:H*0.20}, LW:{x:-220,y:H*0.22} };

          function spawnTeamWithRoles(roles, anchors){
            return roles.map(role => ({ role, num: NUM_BY_ROLE[role]||0, x: W/2 + (anchors[role]?.x||0), y: anchors[role]?.y||H/2, r: 14, phase: Math.random()*6.28, engaged:false, react: 220+Math.random()*220, lag:0, homeX: W/2 + (anchors[role]?.x||0), homeY: anchors[role]?.y||H/2 }));
          }

          const state = {
            t: performance.now(),
            ball: { x: W/2, y: H/2, vx: 0, vy: 0, r: BALL_R, spin: 0 },
            charging: false, t0: 0, aim: { x: W/2, y: H*0.5 },
            defenders: spawnTeamWithRoles(ROLES_FR, ANCHORS_FR),
            mates:     spawnTeamWithRoles(ROLES_PT, ANCHORS_PT),
            tackleCd: 0, protect: 0,
            ai: { carrier: null, shot: null, ptCarrier: -1 },
            score: 0, against: 0,
            gkFR: { x: W/2, y: 52, speed: 520, react: GK_REACT_MS, reactT: 0 },
            gkPT: { x: W/2, y: H-52, speed: 520, react: GK_REACT_MS, reactT: 0 },
            trapLock: 0, trapOwner: -1, receiverIndex: -1,
            selectedIdx: 0,
            keys: { w:false,a:false,s:false,d:false, ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false },
            mod: { shift:false, ctrl:false },
            levelIdx: 0, goalsToAdvance: 2, levelProgress: 0, cfg: null,
          };

          function applyLevel(i){ state.levelIdx = Math.max(0, Math.min(LEVELS.length-1, i)); state.cfg = LEVELS[state.levelIdx]; }
          function advanceLevel(){ applyLevel(state.levelIdx + 1); }
          applyLevel(0);

          setDiag([
            { name: 'France outfield', pass: state.defenders.length===NUM_DEFENDERS, info: String(state.defenders.length) },
            { name: 'Portugal outfield', pass: state.mates.length===NUM_TEAMMATES, info: String(state.mates.length) },
            { name: 'Engagers cap', pass: true, info: 'max ' + (state.cfg?.maxEngagers ?? 2) },
          ]);

          function toWorld(e){ const r = cvs.getBoundingClientRect(); const rawX = (e.clientX - r.left) * (cvs.width / r.width) / dpr; const rawY = (e.clientY - r.top)  * (cvs.height / r.height) / dpr; return unproject(rawX, rawY); }

          function mousedown(e){
            if (e.button===2) { e.preventDefault(); passToSelected(); return; }
            if (e.button!==0) return;
            state.charging = true; state.t0 = performance.now();
            const p = toWorld(e); state.aim.x = p.x; state.aim.y = p.y;
            state.mod.shift = e.shiftKey; state.mod.ctrl = e.ctrlKey;
          }
          function mousemove(e){ if(!state.charging) return; const p = toWorld(e); state.aim = p; }
          function mouseup(e){ if(e.button!==0) return; if(!state.charging) return; state.charging=false; shoot(); }
          function context(e){ e.preventDefault(); }

          // Touch controls (mobile-first):
          // - 1 finger press/drag/release = aim + shoot (hold longer = stronger shot)
          // - 2 finger tap = pass to selected teammate
          // - swipe left/right = switch selected teammate
          let touchStartX = 0;
          let touchStartT = 0;
          function touchToWorld(touch){
            const r = cvs.getBoundingClientRect();
            const rawX = (touch.clientX - r.left) * (cvs.width / r.width) / dpr;
            const rawY = (touch.clientY - r.top)  * (cvs.height / r.height) / dpr;
            return unproject(rawX, rawY);
          }
          function touchstart(e){
            if (!e.changedTouches || e.changedTouches.length === 0) return;
            if (e.touches && e.touches.length >= 2) {
              e.preventDefault();
              passToSelected();
              return;
            }
            const t = e.changedTouches[0];
            const p = touchToWorld(t);
            state.charging = true;
            state.t0 = performance.now();
            touchStartT = state.t0;
            touchStartX = t.clientX;
            state.aim.x = p.x; state.aim.y = p.y;
            // No shift/ctrl on mobile
            state.mod.shift = false; state.mod.ctrl = false;
            e.preventDefault();
          }
          function touchmove(e){
            if (!state.charging) return;
            const t = e.changedTouches[0];
            const p = touchToWorld(t);
            state.aim = p;
            e.preventDefault();
          }
          function touchend(e){
            if (!state.charging) return;
            const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
            const dt = performance.now() - touchStartT;
            const dx = t ? (t.clientX - touchStartX) : 0;
            // Swipe to change selected teammate
            if (Math.abs(dx) > 60 && dt < 350) {
              cycleSelected(dx > 0 ? 1 : -1);
              state.charging = false;
              e.preventDefault();
              return;
            }
            state.charging = false;
            shoot();
            e.preventDefault();
          }

          function keydown(e){ const k = e.key; if (k in state.keys) state.keys[k] = true; if (k === 'Tab') { e.preventDefault(); cycleSelected(e.shiftKey?-1:1); } }
          function keyup(e){ const k=e.key; if (k in state.keys) state.keys[k] = false; }

          window.addEventListener('mousedown', mousedown);
          window.addEventListener('mousemove', mousemove);
          window.addEventListener('mouseup', mouseup);
          window.addEventListener('contextmenu', context);
          window.addEventListener('keydown', keydown);
          window.addEventListener('keyup', keyup);

          // Mobile touch listeners on the canvas (avoid scrolling)
          cvs.addEventListener('touchstart', touchstart, { passive: false });
          cvs.addEventListener('touchmove', touchmove, { passive: false });
          cvs.addEventListener('touchend', touchend, { passive: false });

          function cycleSelected(dir){ const n = state.mates.length; state.selectedIdx = (((state.selectedIdx + dir) % n) + n) % n; }

          function shoot(){
            const ms = Math.min(900, performance.now()-state.t0);
            const pwr = Math.max(0.15, Math.min(1, ms/900));
            const b = state.ball;
            const dx = state.aim.x - b.x, dy = state.aim.y - b.y; const d = Math.hypot(dx,dy) || 1;

            const finesse = state.mod.shift && !state.mod.ctrl;
            const driven  = state.mod.ctrl && !state.mod.shift;
            const speedF  = finesse ? FINESSE_SPEED_F : driven ? DRIVEN_SPEED_F : 1.0;

            const baseAngle = Math.atan2(dy, dx);
            const spray = (Math.random()-0.5) * SHOT_SPRAY;
            const a = baseAngle + spray;
            const spd = (300 + pwr*500) * speedF;
            b.vx = Math.cos(a) * spd; b.vy = Math.sin(a) * spd;
            b.spin = finesse ? (dx>0? +FINESSE_SPIN : -FINESSE_SPIN) : 0;

            state.protect = 120;
            state.receiverIndex = -1; state.trapLock = 250; state.trapOwner = -1; state.ai.ptCarrier = -1;
          }

          function passToSelected(){ passToIndex(state.selectedIdx); }
          function passToIndex(idx){
            const b = state.ball; const m = state.mates[idx]; if (!m) return;
            const dx = m.x - b.x, dy = m.y - b.y; const d = Math.hypot(dx,dy)||1;
            const speed = Math.min(PASS_MAX, Math.max(PASS_MIN, 5*d));
            state.ball.vx = (dx/d)*speed; state.ball.vy = (dy/d)*speed; b.spin = 0;
            state.protect = (state.cfg?.passGrace ?? 700); state.receiverIndex = idx; state.trapLock = 250; state.trapOwner = -1; state.ai.ptCarrier = -1;
          }

          let raf=0;
          function gameLoop(t){ const dt = Math.min(0.033, (t - state.t)/1000); state.t = t; update(dt); draw(); raf = requestAnimationFrame(gameLoop); }
          raf = requestAnimationFrame(gameLoop);

          function update(dt){
            state.tackleCd = Math.max(0, state.tackleCd - dt*1000);
            state.protect  = Math.max(0, state.protect  - dt*1000);
            state.trapLock = Math.max(0, state.trapLock - dt*1000);
            const b = state.ball;

            b.vx += (b.spin || 0) * dt;
            b.x  += b.vx*dt; b.y += b.vy*dt;
            b.vx *= (1-0.08*dt); b.vy *= (1-0.08*dt);

            const pad=24; if (b.x < pad + b.r){ b.x = pad + b.r; if (b.vx<0) b.vx = -b.vx*RESTITUTION; }
            if (b.x > W - pad - b.r){ b.x = W - pad - b.r; if (b.vx>0) b.vx = -b.vx*RESTITUTION; }
            if (b.y < pad + b.r){ b.y = pad + b.r; if (b.vy<0) b.vy = -b.vy*RESTITUTION; }
            if (b.y > H - pad - b.r){ b.y = H - pad - b.r; if (b.vy>0) b.vy = -b.vy*RESTITUTION; }

            const awayY = 36, homeY = H-36;
            if (b.y - b.r < awayY && Math.abs(b.x - W/2) < GOAL_W/2) { state.score++; state.levelProgress++; if (state.levelProgress >= state.goalsToAdvance) { state.levelProgress = 0; advanceLevel(); } resetBall(); }
            if (b.y + b.r > homeY && Math.abs(b.x - W/2) < GOAL_W/2) { state.against++; resetBall(); }

            for (let i=0;i<state.mates.length;i++){
              const m = state.mates[i]; const d = Math.hypot(b.x-m.x, b.y-m.y);
              if (state.trapLock<=0 && d < m.r + b.r - 1){ b.x=m.x; b.y=m.y-12; b.vx=0; b.vy=0; b.spin=0; state.protect=500; state.receiverIndex=i; state.trapLock=300; state.trapOwner=i; state.ai.ptCarrier=i; break; }
            }

            for (let i=0;i<state.mates.length;i++){
              const m = state.mates[i]; m.phase += dt; const homeX = m.homeX, homeY = m.homeY; let targetX=homeX, targetY=homeY;
              if (i === state.selectedIdx) {
                const vx = ((state.keys.d||state.keys.ArrowRight)?1:0) + ((state.keys.a||state.keys.ArrowLeft)?-1:0);
                const vy = ((state.keys.s||state.keys.ArrowDown)?1:0) + ((state.keys.w||state.keys.ArrowUp)?-1:0);
                const mag = Math.hypot(vx,vy)||1; const adv = TEAMMATE_SPEED*dt; m.x += (vx/mag)*adv; m.y += (vy/mag)*adv;
                m.x = Math.max(24, Math.min(W-24, m.x)); m.y = Math.max(24, Math.min(H-24, m.y));
              } else {
                let tY = Math.min(homeY, state.ball.y + 140);
                let tX = homeX + Math.sin(m.phase*1.1)*20;
                const dx = tX - m.x, dy = tY - m.y; const dL = Math.hypot(dx,dy)||1; const adv = Math.min(TEAMMATE_SPEED*0.8*dt, dL);
                m.x += (dx/dL)*adv; m.y += (dy/dL)*adv;
              }
            }

            if (state.ai.ptCarrier === state.selectedIdx) { const m = state.mates[state.selectedIdx]; b.x=m.x; b.y=m.y-12; b.vx=0; b.vy=0; b.spin=0; }
            else if (state.ai.ptCarrier >= 0) { const i = state.ai.ptCarrier; const m = state.mates[i]; const adv = TEAMMATE_SPEED * dt; const dy = Math.max(awayY+24, m.y - adv) - m.y; m.y += dy; b.x=m.x; b.y=m.y-12; b.vx=0; b.vy=0; }

            gkUpdate(state.gkFR, b, true, dt);
            gkUpdate(state.gkPT, b, false, dt);
            gkSave(state.gkFR, b, true);
            gkSave(state.gkPT, b, false);

            const sorted = state.defenders.map(d=>({ d, dist: Math.hypot(d.x-b.x, d.y-b.y) })).sort((a,b)=>a.dist-b.dist);
            const engaged = new Set(); const MAX_E = state.cfg?.maxEngagers ?? MAX_ENGAGERS; const RAD_E = state.cfg?.engageRadius ?? ENGAGE_RADIUS;
            for (const e of sorted){ if (engaged.size>=MAX_E) break; if (e.dist<RAD_E) engaged.add(e.d); }

            for (const p of state.defenders){
              const isEngaging = engaged.has(p);
              if (isEngaging && !p.engaged){ p.lag = p.react/1000; p.engaged = true; }
              if (!isEngaging && p.engaged){ p.engaged = false; p.lag = 0; }
              const anchor = { x:p.homeX, y:p.homeY };
              let tx = anchor.x, ty = anchor.y;
              if (isEngaging){ if (p.lag>0) p.lag -= dt; else { const leadX=b.x+b.vx*0.35, leadY=b.y+b.vy*0.35; tx = leadX; ty = leadY; } }
              const dx = tx - p.x, dy = ty - p.y; const dist = Math.hypot(dx,dy)||1; const adv = Math.min((state.cfg?.defenderSpeed ?? DEFENDER_SPEED)*dt*(isEngaging?1:0.7), dist);
              p.x += (dx/dist)*adv; p.y += (dy/dist)*adv; p.phase += dt;

              const bd = Math.hypot(b.x-p.x, b.y-p.y); const bs = Math.hypot(b.vx,b.vy);
              if (state.ai.carrier!==p && state.protect<=0 && state.tackleCd<=0 && bd < p.r + b.r && bs <= (state.cfg?.captureSpeedMax ?? CAPTURE_SPEED_MAX)){
                state.ai.carrier = p; state.tackleCd = 120; state.protect = 250; state.ai.ptCarrier = -1; b.spin=0;
              }
              if (state.ai.carrier === p){ const distToHome = (H-36) - p.y; if (distToHome < 60 && Math.abs(p.x - W/2) < GOAL_W/2 - 20){ const speed = 520 + Math.random()*160; const dxs=(W/2-p.x), dys=((H-36)-p.y-6); const Ls=Math.hypot(dxs,dys)||1; b.x=p.x; b.y=p.y-6; b.vx=(dxs/Ls)*speed; b.vy=(dys/Ls)*speed; state.ai.carrier=null; state.protect=40; } else { b.x=p.x; b.y=p.y-12; b.vx=0; b.vy=0; }
              }
            }
          }

          function gkUpdate(gk, b, topGoal, dt){
            const goalY = topGoal ? 36 : H-36;
            const toward = topGoal ? (b.vy < 0) : (b.vy > 0);
            gk.reactT = Math.max(0, gk.reactT - dt*1000);
            if (!toward) return;
            const t = Math.abs((goalY - b.y) / (b.vy || 1e-6));
            const projX = b.x + b.vx * t;
            const leftBound = W/2 - GOAL_W/2 + 16, rightBound = W/2 + GOAL_W/2 - 16;
            const side = Math.sign((b.x - W/2) || 0.0001);
            const bias = 0.65;
            const nearPostX = side > 0 ? rightBound : leftBound;
            let targetX = projX * (1-bias) + nearPostX * bias;
            targetX = Math.max(leftBound, Math.min(rightBound, targetX));
            if (gk.reactT <= 0){
              const moveStep = gk.speed * dt;
              gk.x += Math.max(-moveStep, Math.min(moveStep, targetX - gk.x));
              gk.reactT = GK_REACT_MS * 0.2;
            }
          }

          function gkSave(gk, b, topGoal){
            const withinX = Math.abs(b.x - gk.x) < 42;
            const speed = Math.hypot(b.vx,b.vy);
            if (topGoal){
              if (b.y - b.r < gk.y + 18 && withinX && b.vy < 0){
                if (speed < GK_HOLD_SPEED){ b.vx=0; b.vy=0; b.x=gk.x; b.y=gk.y+12; state.protect=260; }
                else { const dir = Math.sign((b.x - gk.x) || 0.0001); const ang = 0.35 + Math.random()*0.35; const nv = rotate(b.vx, b.vy, dir*ang); b.vx = nv.x * 0.9; b.vy = Math.abs(nv.y) * 0.55; b.y = gk.y + 12; state.protect = 180; }
              }
            } else {
              if (b.y + b.r > gk.y - 18 && withinX && b.vy > 0){
                if (speed < GK_HOLD_SPEED){ b.vx=0; b.vy=0; b.x=gk.x; b.y=gk.y-12; state.protect=260; }
                else { const dir = Math.sign((b.x - gk.x) || 0.0001); const ang = 0.35 + Math.random()*0.35; const nv = rotate(b.vx, b.vy, dir*ang); b.vx = nv.x * 0.9; b.vy = -Math.abs(nv.y) * 0.55; b.y = gk.y - 12; state.protect = 180; }
              }
            }
          }

          function rotate(vx,vy,angle){ const c=Math.cos(angle), s=Math.sin(angle); return { x: vx*c - vy*s, y: vx*s + vy*c }; }
          function resetBall(){ state.ball.x = W/2; state.ball.y = H/2; state.ball.vx=0; state.ball.vy=0; state.ball.spin=0; state.ai.carrier=null; state.ai.ptCarrier=-1; state.protect=0; state.receiverIndex=-1; state.gkFR.reactT=0; state.gkPT.reactT=0; }

          function drawField(ctx2){ /* identical to your version */ }
          function drawCrowd(ctx2){ /* identical to your version */ }
          function drawPlayer(ctx2,x,y,kit,highlight=false,num=0){ /* identical to your version */ }
          function drawKeeper(ctx2,x,y,kit){ /* identical to your version */ }
          function drawBall(ctx2,b){ /* identical to your version */ }
          function drawAim(ctx2,b,aim){ /* identical to your version */ }

          function draw(){
            const scaleX = cvs.width / W; const scaleY = cvs.height / H; const c = ctx; c.save(); c.scale(scaleX, scaleY);
            drawField(c);
            for (const d of state.defenders){ drawPlayer(c, d.x, d.y, KIT_FR, false, d.num); }
            for (let i=0;i<state.mates.length;i++){ const m = state.mates[i]; const hl = (i===state.receiverIndex) || (i===state.selectedIdx); drawPlayer(c, m.x, m.y, KIT_PT, hl, m.num); }
            drawKeeper(c, state.gkFR.x, state.gkFR.y, { jersey:'#FACC15', shorts:'#1f2937', socks:'#F59E0B' });
            drawKeeper(c, state.gkPT.x, state.gkPT.y, { jersey:'#0EA5E9', shorts:'#1f2937', socks:'#38BDF8' });
            drawBall(c, state.ball);
            if (state.charging){ drawAim(c, state.ball, state.aim); }
            c.fillStyle='rgba(0,0,0,.5)'; c.fillRect(12,12,580,110);
            c.fillStyle='#fff'; c.font='14px system-ui';
            c.fillText(`Goals (PT): ${state.score}`, 20, 32);
            c.fillText(`Against (FR): ${state.against}`, 20, 52);
            c.fillText(`Level: ${state.levelIdx+1}/${LEVELS.length} (${LEVELS[state.levelIdx]?.name||''})  •  Progress: ${state.levelProgress}/${state.goalsToAdvance}`, 20, 72);
            c.fillText(`Selected: #${state.selectedIdx+1}  •  Controls: Tab switch • WASD/Arrows move • RMB pass • LMB shoot (Shift=finesse, Ctrl=driven)`, 20, 92);
            c.restore();
          }

          return () => {
            cancelAnimationFrame(raf);
            window.removeEventListener('mousedown', mousedown);
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
            window.removeEventListener('contextmenu', context);
            window.removeEventListener('resize', resize);
            window.removeEventListener('keydown', keydown);
            window.removeEventListener('keyup', keyup);
          };
        }, []);

        return (
          <div style={{minHeight:'100vh', background:'#0b0b0b', color:'#fff', display:'flex', flexDirection:'column', alignItems:'center'}}>
            <div style={{width:'100%', maxWidth:1100, padding:'12px 16px', display:'flex', justifyContent:'space-between', alignItems:'center', position:'sticky', top:0, background:'rgba(11,11,11,0.7)', backdropFilter:'blur(6px)', borderBottom:'1px solid rgba(255,255,255,.1)'}}>
              <div style={{display:'flex', alignItems:'center', gap:12}}>
                <div style={{width:32, height:32, borderRadius:14, background:'linear-gradient(135deg,#34d399,#14b8a6)'}} />
                <div style={{fontWeight:600}}>KickCraft — Realistic 11v11 (pseudo-3D 2D)</div>
              </div>
              <div style={{display:'flex', alignItems:'center', gap:8, fontSize:12}}>
                <span style={{color:'#94a3b8'}}>FR kit: <span style={{color:'#60a5fa'}}>blue</span>/<span style={{color:'#e2e8f0'}}>white</span>/<span style={{color:'#f87171'}}>red</span></span>
                <span style={{color:'#94a3b8'}}>•</span>
                <span style={{color:'#94a3b8'}}>PT kit: <span style={{color:'#22c55e'}}>green</span>/<span style={{color:'#f87171'}}>red</span>/<span style={{color:'#facc15'}}>yellow</span></span>
              </div>
            </div>

            <div ref={wrapRef} style={{width:'100%', maxWidth:1100, padding:'16px', boxSizing:'border-box'}}>
              <div style={{position:'relative', width:'100%', height:'70vh', borderRadius:16, overflow:'hidden', border:'1px solid rgba(255,255,255,.1)'}}>
                <canvas ref={canvasRef} />
                <div className="hud" style={{position:'absolute', left:12, bottom:12}}>
                  Controls: Tab switch • WASD/Arrows move • <b>RMB</b> pass • <b>LMB</b> shoot (Shift=finesse, Ctrl=driven) • 11v11
                </div>
              </div>
            </div>

            <div style={{width:'100%', maxWidth:1100, padding:'0 16px 24px', color:'#94a3b8', fontSize:12, textAlign:'center'}}>
              This preview uses a pseudo-3D canvas so it always loads here. The full first-person 3D version is ready in the Vercel project we packaged.
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<KickCraft />);
    </script>
  </body>
</html>
